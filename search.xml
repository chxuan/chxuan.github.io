<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[使用方便的单例类]]></title>
      <url>http://yoursite.com/2016/11/27/%E4%BD%BF%E7%94%A8%E6%96%B9%E4%BE%BF%E7%9A%84%E5%8D%95%E4%BE%8B%E7%B1%BB/</url>
      <content type="text"><![CDATA[前言我们在软件开发中会经常用到设计模式，其中运用的最为广泛的设计模式就是单例，下面是实现单例类的代码。 单例类1234567891011121314151617181920212223242526272829#pragma oncetemplate &lt;typename T&gt;class singleton&#123;public: singleton() = delete; virtual ~singleton() = delete; singleton(const singleton&amp;) = delete; singleton&amp; operator=(const singleton&amp;) = delete; template&lt;typename... Args&gt; static T&amp; get_instance(Args&amp;&amp;... args) &#123; // C++11保证单例的线程安全 static T t&#123; std::forward&lt;Args&gt;(args)... &#125;; return t; &#125;&#125;;#define DEFINE_SINGLETON(class_name) \public: \friend class singleton&lt;class_name&gt;; \using singleton = singleton&lt;class_name&gt;; \private: \virtual ~class_name() &#123;&#125; \class_name(const class_name&amp;) = delete; \class_name&amp; operator=(const class_name&amp;) = delete; \public: 使用12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include "singleton.h"class test&#123; // 只需要加入一句代码，就可以将test类变为单例类 DEFINE_SINGLETON(test);public: test() = default; void print() &#123; std::cout &lt;&lt; "Hello world" &lt;&lt; std::endl; &#125;&#125;;class test2&#123; // 只需要加入一句代码，就可以将test2类变为单例类 DEFINE_SINGLETON(test2);public: test2(const std::string&amp; str) : str_(str) &#123;&#125; void print() &#123; std::cout &lt;&lt; str_ &lt;&lt; std::endl; &#125;private: std::string str_;&#125;;int main()&#123; // 没有参数的单例 test::singleton::get_instance().print(); // 带有参数的单例 test2::singleton::get_instance("nihao").print(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[好用的http client库CPP REST SDK]]></title>
      <url>http://yoursite.com/2016/11/01/%E5%A5%BD%E7%94%A8%E7%9A%84http%20client%E5%BA%93CPP%20REST%20SDK/</url>
      <content type="text"><![CDATA[前言C++中http client库本身就少，好用的就更少了，在了解微软开源的CPP REST SDK库之前，我知道的C++ http client库有libcurl（这个是C语言的），Qt的QNetworkAccessManager，还有VC++ http client，Qt的QNetworkAccessManager库我在开发CZPlayer的时候用来下载过音乐、专辑图片和歌词，不得不说Qt提供的API还是比较好用的，如果不涉及界面开发，难道我们在linux上就只能用libcurl，在windows上就用VC++的http client？答案是否定的，在绝望之际CPP REST SDK出现在我的眼前，CPP REST SDK是微软开源的基于PPL的异步http client，网络层使用的是Boost.Asio，跨平台，并且支持json解析，在使用CPP REST SDK之前要确保你已经安装了boost和openssl，下面是微软官方提供的例子。 微软官方例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cpprest/http_client.h&gt;#include &lt;cpprest/filestream.h&gt;using namespace utility; // Common utilities like string conversionsusing namespace web; // Common features like URIs.using namespace web::http; // Common HTTP functionalityusing namespace web::http::client; // HTTP client featuresusing namespace concurrency::streams; // Asynchronous streamsint main(int argc, char* argv[])&#123; auto fileStream = std::make_shared&lt;ostream&gt;(); // Open stream to output file. pplx::task&lt;void&gt; requestTask = fstream::open_ostream(U("results.html")).then([=](ostream outFile) &#123; *fileStream = outFile; // Create http_client to send the request. http_client client(U("http://www.bing.com/")); // Build request URI and start the request. uri_builder builder(U("/search")); builder.append_query(U("q"), U("cpprestsdk github")); return client.request(methods::GET, builder.to_string()); &#125;) // Handle response headers arriving. .then([=](http_response response) &#123; printf("Received response status code:%u\n", response.status_code()); // Write response body into the file. return response.body().read_to_end(fileStream-&gt;streambuf()); &#125;) // Close the file stream. .then([=](size_t) &#123; return fileStream-&gt;close(); &#125;); // Wait for all the outstanding I/O to complete and handle any exceptions try &#123; requestTask.wait(); &#125; catch (const std::exception &amp;e) &#123; printf("Error exception:%s\n", e.what()); &#125; return 0;&#125; 上面的例子主要内容是访问一个网站并将该内容保存在results.html里面，这里用到了微软自家的PPL并行计算库（还有一个是英特尔的TBB），该例子使用lambda表达式作为异步回调的handler，打开文件流、请求、回应和关闭文件流都是异步的，为了方便起见，我们将该例子改为同步方式。 使用同步方式1234567891011121314auto fileStream = std::make_shared&lt;ostream&gt;();ostream outFile = fstream::open_ostream(U("results.html")).get();*fileStream = outFile;// Create http_client to send the request.http_client client(U("http://www.bing.com/"));// Build request URI and start the request.uri_builder builder(U("/search"));builder.append_query(U("q"), U("cpprestsdk github"));http_response response = client.request(methods::GET, builder.to_string()).get();// Write response body into the file.response.body().read_to_end(fileStream-&gt;streambuf()).get();fileStream-&gt;close().get(); 使用同步方式的代码比较清晰，可以看到每一个函数调用后面都会调用get函数，因为CPP REST SDK是基于PPL的，所以在request、read_to_end、close等函数调用后都会返回一个Task对象，而Task里面的get和wait函数是等待任务执行完成。 实战我之前在看别人博客的时候看到每一篇博客前都有一副图，看起来比较好看，听博主讲他是使用bing的每日一图，后来我也效仿，我在主题之家找到了自己比较喜欢的图片，最开始自己写博客的时候都是直接去主题之家一页一页的找看，然后再下载图片，写了几篇博客之后感觉每次都要去下载图片感觉有点low，所以我决定直接将主题之家的某类型的图片都下载下来，这样选图片就方便多了，下面是我在主题之家抓图的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;memory&gt;#include &lt;regex&gt;#include &lt;cpprest/http_client.h&gt;#include &lt;cpprest/filestream.h&gt;#include &lt;cpprest/containerstream.h&gt;// 请求并解析urlbool get_result(const std::string&amp; url, const std::string&amp; pattern, std::vector&lt;std::string&gt;&amp; vec)&#123; try &#123; web::http::client::http_client client(web::uri(utility::conversions::to_string_t(url))); web::http::http_response response = client.request(web::http::methods::GET).get(); concurrency::streams::stringstreambuf buffer; response.body().read_to_end(buffer).get(); std::string&amp; str = buffer.collection(); // 使用C++11提供的正则表达式库 std::regex r(pattern); for (std::sregex_iterator iter(str.begin(), str.end(), r), end; iter != end; ++iter) &#123; std::cout &lt;&lt; iter-&gt;str() &lt;&lt; std::endl; vec.emplace_back(iter-&gt;str()); &#125; &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl; return false; &#125; return true;&#125;// 获取图片bool get_result(const std::string&amp; url, std::string&amp; picture)&#123; try &#123; web::http::client::http_client client(web::uri(utility::conversions::to_string_t(url))); web::http::http_response response = client.request(web::http::methods::GET).get(); concurrency::streams::stringstreambuf buffer; response.body().read_to_end(buffer).get(); picture = buffer.collection(); &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl; return false; &#125; return true;&#125;// 保存图片bool write_to_file(const std::string&amp; file_path, const std::string&amp; data)&#123; try &#123; std::ofstream file; file.open(file_path, std::ios::out | std::ios::binary); if (!file.good()) &#123; return false; &#125; file.write(data.c_str(), data.size()); file.close(); &#125; catch (std::exception&amp; e) &#123; std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl; return false; &#125; return true;&#125;int main()&#123; // [1] 请求每一页，将子页面的url保存在sub_url_vec里面 std::vector&lt;std::string&gt; sub_url_vec; std::string pattern = "/desk/[0-9]+.htm"; for (int i = 1; i &lt;= 32; ++i) &#123; // 创意主题 std::string url = "http://www.51ztzj.com/dbizhi/category_27_" + std::to_string(i) + ".htm#content_anchor"; std::cout &lt;&lt; "Start get " &lt;&lt; i &lt;&lt; " page, url: " &lt;&lt; url &lt;&lt; std::endl; // 请求并解析url if (!get_result(url, pattern, sub_url_vec)) &#123; std::cout &lt;&lt; "Get " &lt;&lt; i &lt;&lt; " page failed" &lt;&lt; std::endl; &#125; &#125; // 最终的图片url：http://img.51ztzj.com//upload/image/20130220/2013022014_670x419.jpg // [2] 将子页面的图片url解析出来放入picture_url_vec std::vector&lt;std::string&gt; picture_url_vec; pattern = "http://img.51ztzj.com//upload/image/.+/.+_670x419.jpg"; for (std::size_t i = 0; i &lt; sub_url_vec.size(); ++i) &#123; std::string url = "http://www.51ztzj.com" + sub_url_vec[i]; std::cout &lt;&lt; "Start get " &lt;&lt; i + 1 &lt;&lt; " sub page, url: " &lt;&lt; url &lt;&lt; std::endl; // 请求并解析url if (!get_result(url, pattern, picture_url_vec)) &#123; std::cout &lt;&lt; "Get " &lt;&lt; i + 1 &lt;&lt; " sub page failed" &lt;&lt; std::endl; &#125; &#125; // [3] 最后遍历picture_url_vec，然后一个一个的下载图片 for (std::size_t i = 0; i &lt; picture_url_vec.size(); ++i) &#123; std::cout &lt;&lt; "Start download " &lt;&lt; i + 1 &lt;&lt; " picture, url: " &lt;&lt; picture_url_vec[i] &lt;&lt; std::endl; std::string picture; // 获取图片 if (!get_result(picture_url_vec[i], picture)) &#123; std::cout &lt;&lt; "Download " &lt;&lt; i + 1 &lt;&lt; " picture failed" &lt;&lt; std::endl; &#125; std::string file_path = "./download/" + std::to_string(i) + ".jpg"; // 保存图片 if (!write_to_file(file_path, picture)) &#123; std::cout &lt;&lt; "Write to file failed: " &lt;&lt; i + 1 &lt;&lt; std::endl; &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[让boost.variant支持lambda表达式访问]]></title>
      <url>http://yoursite.com/2016/10/29/%E8%AE%A9boost.variant%E6%94%AF%E6%8C%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BF%E9%97%AE/</url>
      <content type="text"><![CDATA[前言之前写个过一篇博客叫《浅谈boost.variant的几种访问方式》，里面讲到了可以通过访问者方式来获取variant的值，但是在重载函数operator()里面只能够获取variant的值，如果要捕获外部变量或调用外部函数比较麻烦，那么有没有一种方法来简化variant的访问呢？当然有，下面我们让variant支持lambda表达式访问(个人博客也发表了《让boost.variant支持lambda表达式访问》)。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;type_traits&gt;#include &lt;boost/variant.hpp&gt;template&lt;typename Function, typename... Args&gt;struct make_overload_impl : make_overload_impl&lt;Function&gt;::type, make_overload_impl&lt;Args...&gt;::type&#123; using type = make_overload_impl; using make_overload_impl&lt;Function&gt;::type::operator(); using make_overload_impl&lt;Args...&gt;::type::operator(); constexpr explicit make_overload_impl(Function&amp;&amp; func, Args&amp;&amp;... args) : make_overload_impl&lt;Function&gt;::type(std::forward&lt;Function&gt;(func)), make_overload_impl&lt;Args...&gt;::type(std::forward&lt;Args&gt;(args)...) &#123;&#125;&#125;;template&lt;typename Function&gt;struct make_overload_impl&lt;Function&gt;&#123; using type = Function;&#125;;template&lt;typename Return, typename... Args&gt;struct make_overload_impl&lt;Return(*)(Args...)&gt;&#123; using type = make_overload_impl; using Function = Return(*)(Args...); constexpr explicit make_overload_impl(const Function&amp;&amp; func) : _func(func) &#123;&#125; constexpr Return operator()(Args&amp;&amp;... args) const &#123; return _func(std::forward&lt;Args&gt;(args)...); &#125;private: Function _func;&#125;;struct make_overload&#123; template&lt;typename... Function, typename Overload = typename make_overload_impl&lt;typename std::decay&lt;Function&gt;::type...&gt;::type&gt; constexpr Overload operator()(Function&amp;&amp;... func) const &#123; return Overload(std::forward&lt;Function&gt;(func)...); &#125;&#125;;template&lt;typename... Args&gt;auto make_visitor(Args&amp;&amp;... args)&#123; return make_overload()(std::forward&lt;Args&gt;(args)...);&#125;int main()&#123; auto visitor = make_visitor ( [](int&amp; i) &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125;, [](std::string&amp; i) &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125; ); boost::variant&lt;int, std::string&gt; v; v = "Hello world"; boost::apply_visitor(visitor, v); v = 100; boost::apply_visitor(visitor, v); return 0;&#125; 该代码也上传到了我的github。 参考资料让BOOST.VARIANT的VISIT支持LAMBDA]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈boost.variant的几种访问方式]]></title>
      <url>http://yoursite.com/2016/10/26/%E6%B5%85%E8%B0%88boost.variant%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/</url>
      <content type="text"><![CDATA[前言variant类型在C++14并没有加入，在cppreference网站上可以看到该类型将会在C++17加入，若想在不支持C++17的编译器上使用variant类型，我们可以通过boost的variant类型，variant类型可以表示任意一种类型和any类型有些相似，但还是有些区别，比如说variant支持的类型需提前定义，而any类型不需要，获取any类型的值需要给出原始类型，然而variant类型支持多种方式访问，其中一种就是通过访问者模式来访问，是不需要给出原始类型的，下面将浅谈variant的几种访问方式(个人博客也发表了《浅谈boost.variant的几种访问方式》)。 使用boost::get123boost::variant&lt;int, std::string&gt; v;v = "Hello world";std::cout &lt;&lt; boost::get&lt;std::string&gt;(v) &lt;&lt; std::endl; 使用boost::get来访问，需要给出原始类型，并且这样做不安全，若类型错误，程序将会抛出异常。 使用RTTI12345678910111213141516171819void var_print(boost::variant&lt;int, std::string&gt;&amp; v) &#123; if (v.type() == typeid(int)) &#123; std::cout &lt;&lt; boost::get&lt;int&gt;(v) &lt;&lt; std::endl; &#125; else if (v.type() == typeid(std::string)) &#123; std::cout &lt;&lt; boost::get&lt;std::string&gt;(v) &lt;&lt; std::endl; &#125; // Else do nothing&#125; int main() &#123; boost::variant&lt;int, std::string&gt; v; v = "Hello world"; var_print(v); return 0;&#125; 使用RTTI技术可以避免类型访问错误而程序异常的情况，但是这样做有点不优雅，每增加一个类型，都需要修改if-else结构，并且使用RTTI会对程序性能有一定影响。 使用访问者模式1234567891011121314151617181920class var_visitor : public boost::static_visitor&lt;void&gt;&#123;public: void operator()(int&amp; i) const &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125; void operator()(std::string&amp; str) const &#123; std::cout &lt;&lt; str &lt;&lt; std::endl; &#125;&#125;;int main() &#123; boost::variant&lt;int, std::string&gt; v; v = "Hello world"; boost::apply_visitor(var_visitor(), v); return 0;&#125; 使用该模式，需要定义一个类并继承于boost::static_visitor，在类里面需要重载()操作符，通过boost::apply_visitor来访问原始类型的值，这样做还是有些繁琐，每增加一个类型，都需要在var_visitor里面增加一个函数，但比使用RTTI里面的修改if-else结构好得多，因为使用访问者模式至少是遵循开放-封闭原则的，即对写开放，对修改封闭。 使用模板函数12345678910111213141516class var_visitor : public boost::static_visitor&lt;void&gt;&#123;public: template&lt;typename T&gt; void operator()(T&amp; i) const &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125;&#125;;int main() &#123; boost::variant&lt;int, std::string&gt; v; v = "Hello world"; boost::apply_visitor(var_visitor(), v); return 0;&#125; 将operator()改成了模板函数的好处就是不用关心variant支持多少类型。 参考资料boost官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用C++11实现一个半同步半异步线程池]]></title>
      <url>http://yoursite.com/2016/10/23/%E4%BD%BF%E7%94%A8C++11%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="text"><![CDATA[前言C++11之前我们使用线程需要系统提供API、posix线程库或者使用boost提供的线程库，C++11后就加入了跨平台的线程类std::thread，线程同步相关类std::mutex、std::lock_guard、std::condition_variable、std::atomic以及异步操作相关类std::async、std::future、std::promise等等，这使得我们编写跨平台的多线程程序变得容易，线程的一个高级应用就是线程池，使用线程池可以充分利用多核CPU的并行计算能力，以及避免了使用单个线程的创建和销毁的开销，所以线程池在实际项目中用的很广泛，很多RPC框架都是用了线程池来处理事务，比如说Thrift，easyrpc等等，接下来我们将使用C++11来实现一个通用的半同步半异步线程池(个人博客也发表了《使用C++11实现一个半同步半异步线程池》)。 实现一个半同步半异步线程池分为三层。 同步服务层：它处理来自上层的任务请求,上层的请求可能是并发的,这些请求不是马上就会被处理的,而是将这些任务放到一个同步排队层中,等待处理。 同步排队层: 来自上层的任务请求都会加到排队层中等待处理，排队层实际就是一个std::queue。 异步服务层: 这一层中会有多个线程同时处理排队层中的任务,异步服务层从同步排队层中取出任务并行的处理。 这三个层次之间需要使用std::mutex、std::condition_variable来进行事件同步，线程池的实现代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#ifndef _THREADPOOL_H#define _THREADPOOL_H#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;memory&gt;#include &lt;functional&gt;#include &lt;condition_variable&gt;#include &lt;atomic&gt;#include &lt;type_traits&gt;static const std::size_t max_task_quque_size = 100000;static const std::size_t max_thread_size = 30;class thread_pool&#123;public: using work_thread_ptr = std::shared_ptr&lt;std::thread&gt;; using task_t = std::function&lt;void()&gt;; explicit thread_pool() : _is_stop_threadpool(false) &#123;&#125; ~thread_pool() &#123; stop(); &#125; void init_thread_num(std::size_t num) &#123; if (num &lt;= 0 || num &gt; max_thread_size) &#123; std::string str = "Number of threads in the range of 1 to " + std::to_string(max_thread_size); throw std::invalid_argument(str); &#125; for (std::size_t i = 0; i &lt; num; ++i) &#123; work_thread_ptr t = std::make_shared&lt;std::thread&gt;(std::bind(&amp;thread_pool::run_task, this)); _thread_vec.emplace_back(t); &#125; &#125; // 支持普通全局函数、静态函数、以及lambda表达式 template&lt;typename Function, typename... Args&gt; void add_task(const Function&amp; func, Args... args) &#123; if (!_is_stop_threadpool) &#123; // 用lambda表达式来保存函数地址和参数 task_t task = [&amp;func, args...]&#123; return func(args...); &#125;; add_task_impl(task); &#125; &#125; // 支持函数对象（仿函数） template&lt;typename Function, typename... Args&gt; typename std::enable_if&lt;std::is_class&lt;Function&gt;::value&gt;::type add_task(Function&amp; func, Args... args) &#123; if (!_is_stop_threadpool) &#123; task_t task = [&amp;func, args...]&#123; return func(args...); &#125;; add_task_impl(task); &#125; &#125; // 支持类成员函数 template&lt;typename Function, typename Self, typename... Args&gt; void add_task(const Function&amp; func, Self* self, Args... args) &#123; if (!_is_stop_threadpool) &#123; task_t task = [&amp;func, &amp;self, args...]&#123; return (*self.*func)(args...); &#125;; add_task_impl(task); &#125; &#125; void stop() &#123; // 保证terminate_all函数只被调用一次 std::call_once(_call_flag, [this]&#123; terminate_all(); &#125;); &#125;private: void add_task_impl(const task_t&amp; task) &#123; &#123; // 任务队列满了将等待线程池消费任务队列 std::unique_lock&lt;std::mutex&gt; locker(_task_queue_mutex); while (_task_queue.size() == max_task_quque_size &amp;&amp; !_is_stop_threadpool) &#123; _task_put.wait(locker); &#125; _task_queue.emplace(std::move(task)); &#125; // 向任务队列插入了一个任务并提示线程池可以来取任务了 _task_get.notify_one(); &#125; void terminate_all() &#123; _is_stop_threadpool = true; _task_get.notify_all(); for (auto&amp; iter : _thread_vec) &#123; if (iter != nullptr) &#123; if (iter-&gt;joinable()) &#123; iter-&gt;join(); &#125; &#125; &#125; _thread_vec.clear(); clean_task_queue(); &#125; void run_task() &#123; // 线程池循环取任务 while (true) &#123; task_t task = nullptr; &#123; // 任务队列为空将等待 std::unique_lock&lt;std::mutex&gt; locker(_task_queue_mutex); while (_task_queue.empty() &amp;&amp; !_is_stop_threadpool) &#123; _task_get.wait(locker); &#125; if (_is_stop_threadpool) &#123; break; &#125; if (!_task_queue.empty()) &#123; task = std::move(_task_queue.front()); _task_queue.pop(); &#125; &#125; if (task != nullptr) &#123; // 执行任务，并通知同步服务层可以向队列放任务了 task(); _task_put.notify_one(); &#125; &#125; &#125; void clean_task_queue() &#123; std::lock_guard&lt;std::mutex&gt; locker(_task_queue_mutex); while (!_task_queue.empty()) &#123; _task_queue.pop(); &#125; &#125;private: std::vector&lt;work_thread_ptr&gt; _thread_vec; std::condition_variable _task_put; std::condition_variable _task_get; std::mutex _task_queue_mutex; std::queue&lt;task_t&gt; _task_queue; std::atomic&lt;bool&gt; _is_stop_threadpool; std::once_flag _call_flag;&#125;;#endif 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;chrono&gt;#include "thread_pool.hpp"void test_task(const std::string&amp; str)&#123; std::cout &lt;&lt; "Current thread id: " &lt;&lt; std::this_thread::get_id() &lt;&lt; ", str: " &lt;&lt; str &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(50));&#125;class Test&#123;public: void print(const std::string&amp; str, int i) &#123; std::cout &lt;&lt; "Test: " &lt;&lt; str &lt;&lt; ", i: " &lt;&lt; i &lt;&lt; std::endl; &#125;&#125;;class Test2&#123;public: void operator()(const std::string&amp; str, int i) &#123; std::cout &lt;&lt; "Test2: " &lt;&lt; str &lt;&lt; ", i: " &lt;&lt; i &lt;&lt; std::endl; &#125;&#125;;int main()&#123; Test t; Test2 t2; thread_pool pool; // 启动10个线程 pool.init_thread_num(10); std::string str = "Hello world"; for (int i = 0; i &lt; 1000; ++i) &#123; // 支持lambda表达式 pool.add_task([]&#123; std::cout &lt;&lt; "Hello ThreadPool" &lt;&lt; std::endl; &#125;); // 支持全局函数 pool.add_task(test_task, str); // 支持函数对象 pool.add_task(t2, str, i); // 支持类成员函数 pool.add_task(&amp;Test::print, &amp;t, str, i); &#125; std::cin.get(); std::cout &lt;&lt; "##############END###################" &lt;&lt; std::endl; return 0;&#125; 测试程序启动了十个线程并调用add_task函数加入了4000个任务，add_task支持普通全局函数、静态函数、类成员函数、函数对象（仿函数）以及lambda表达式，并且支持函数传入，该线程池的实现以及测试代码我已经放到了github上。 参考资料《深入应用C++11–代码优化与工程级应用》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[超级强大的vim配置(vimplus)]]></title>
      <url>http://yoursite.com/2016/10/20/%E8%B6%85%E7%BA%A7%E5%BC%BA%E5%A4%A7%E7%9A%84vim%E9%85%8D%E7%BD%AE-vimplus/</url>
      <content type="text"><![CDATA[前言vim和emacs是linux环境下的文本编辑利器，关于vim和emacs谁更优秀的话题从来没有断过，我在这里就不再评判了，vim是linux下的默认编辑器，学好了vim将会一生受用，我之前学vim是在网上找的一些资料，读博客之类的，使用了几年vim始终感觉没有什么大的进步，后来在vim官网看到vim书籍推荐，其中一本就是《vim实用技巧》，后来果断在京东上买了一本，除了宏相关的没怎么看以外，其他的都看了，加上自己的实际操作，感觉vim技术又上了一个层次，《vim实用技巧》是教会vimer怎么使用vim，使用vim写代码时，给vim装上一些插件，将会如虎添翼，后来我在网上找一些插件来安装，或者在github上搜索别人的vimrc，看别人装了什么插件，自己选择性的安装了一些，使用一段时间后感觉使用vim编辑代码就是一件非常愉快的事情，再加上我最近买的忍者二代机械键盘那简直写代码很带感啊，我最开始自己家的电脑上给vim装了很多插件，后来在公司又要重新搭建vim开发环境，感觉有点麻烦，后来又想有没有什么一键安装、部署之类的小程序，就可以傻瓜式的把开发环境给搭建起来不是很爽吗，vimplus就运运而生了，如果喜欢的朋友请不要吝啬，给个star，废话不多说，直接上安装步骤(个人博客也发表了《超级强大的vim配置(vimplus)》)。 安装123git clone https://github.com/chxuan/vimplus.gitcd ./vimplussudo ./install.sh 现在vimplus支持ubuntu14.04之后的所有ubuntu 64位系列以及centos7 64位，运行install.sh脚本，你就可以一边喝咖啡，一遍看着屏幕刷刷刷的打印就安装部署好了开发环境了，整个过程大约持续40分钟，其中下载编译ycm耗费了大半时间，我有下载好了的YouCompleteMe.tar.gz，省得在github上去下载，很慢的，你懂的，若想要手动安装ycm，需要修改vimplus目录下的.vimrc文件。 123Plugin 'Valloric/MatchTagAlways'#Plugin 'Valloric/YouCompleteMe'Plugin 'docunext/closetag.vim' 将ycm插件那行注释掉，不然还会再去下载ycm，ycm可以最后等vimplus执行完成后再安装~~，接下来需要手动编译ycm。 123456cd ~mv YouCompleteMe.tar.gz ~/.vim/bundle/cd ~/.vim/bundle/tar -xvf YouCompleteMe.tar.gzcd YouCompleteMe./install.py --clang-completer vimplus将自动安装一些软件，比如说。 vim g++ ctags cmake python2 python3 安装的插件我也部分列出来。 Vundle YouCompleteMe NerdTree nerdcommenter Airline auto-pairs DoxygenToolkit ctrlp tagbar vim-devicons vim-surround vim-commentary vim-repeat vim-endwise tabular vim-dirdiff vim-coloresque incsearch.vim vim-startify change-colorscheme etc… 配置YouCompleteMe到这一步，安装已经完成，你会发现~目录有两个文件，一个是vim的配置文件.vimrc，一个是YouCompleteMe的配置文件[.ycm_extra_conf.py][25]，一般来说建立一个main.cpp来写C、C++程序来说是没有问题的，都会有语法补全，当你需要写一些项目并涉及到第三方库时，就需要更改[.ycm_extra_conf.py][26]了，具体步骤如下。 将.ycm_extra_conf.py拷贝的项目的根目录。 更改.ycm_extra_conf.py里面的flags变量，添加三方库路径和工程子目录路径。 使用vim-devicons桌面版linux使用vim-devicons插件会出现乱码，需要设置终端字体为Droid Sans Mono for Powerline Nerd Font Complete，使用xshell等工具连接服务器linux的用户就没有必要使用vim-devicons了，可以在插件目录将vim-devicons目录删除，不然会导致NerdTree的缩进有问题。 快捷键vim的插件需要设置好了快捷键才会发挥它的威力，有些插件的快捷键可以查看各自官网，有些快捷键我自己改过的，下面罗列部分插件的快捷键。 显示目录树 &lt;F3&gt; 显示函数、变量、宏定义等 &lt;F4&gt; 显示静态代码分析结果 &lt;F5&gt; .h .cpp 文件快速切换 &lt;F2&gt; 转到申明 &lt;, + u&gt; 转到定义 &lt;, + i&gt; 打开包含文件 &lt;, + o&gt; Buffer切换 &lt;Ctrl + P/Ctrl + N&gt; 光标位置切换 &lt;Ctrl + O/Ctrl + I&gt; 模糊搜索文件 &lt;Ctrl + f&gt; Surround &lt;ys{motion or text-object}{char}/cs{orig_char}{dest_char}/ds{char}&gt; 注释 &lt;gcc/gcap/gc/,ca/,cA&gt; DirDiff :DirDiff &lt;dir1&gt; &lt;dir2&gt; 重复 . 改变主题 &lt;F10/F9&gt; 部分特性截图语法补全YouCompleteMe就不用多说了，它通过clang编译器提供语法快速补全。 文件搜索ctrlp提供文件搜索，支持模糊查询。 vim-airlinevim-airline提供漂亮的状态栏支持。 vim-surround vim-commentary auto-pairs incsearch.vim vim-devicons vim-coloresque vim-dirdiff vim-startify Change the colorscheme]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用hexo+github搭建个人博客]]></title>
      <url>http://yoursite.com/2016/10/19/%E4%BD%BF%E7%94%A8hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="text"><![CDATA[前言上大学期间都没有做笔记、写博客的习惯，工作以后学的东西多了，接触的东西多了，才发现做笔记是一件很重要的事情，做笔记可以将自己的想法、思路写下来，方便以后查阅，俗话说好记性不如键盘党，做笔记、写博客也可以让自己学会总结、学会分享，今年年初才开始使用cnblogs来写博客，账号已经申请了两年多了，大学期间一直没用，cnblogs写了一段时间发现网上一些大牛都有自己的博客，因为我比较喜欢折腾和装X，所以我也打算搭建一个博客，我不是做web方向的，也不懂jsp、asp.net、php（世界上最好的语言）、webpy等语言和技术（大学时学过，后来就忘了），之前我看到我同学基于WordPress搭建了一个博客，这个需要数据库啊，服务器之类的，感觉有点麻烦，后来在网上查阅资料看到hexo、jekyll配合github就可以用来搭建博客，github作为服务器这样还省去了租用服务器的费用，有人会问国内的coding也可以作为部署服务器啊，还快些，我只想说信仰不同，不相为谋，存储图片我也是用的github，没有用七牛的，最后我选择的hexo + github方案来制作个人博客，我是在ubuntu上搭建的，在windows和mac上搭建的朋友本篇博客还是有参考意义，下面是详细的制作过程(个人博客也发表了《使用hexo+github搭建个人博客》)。 安装git部署服务器需要使用github，所以git成了必要工具。 1sudo apt-get install git 安装node.js我直接在node.js的官网下载二进制包来安装的，下载过后，解压，设置软链接。 12ln -s /your/nodejs/dir/bin/node /usr/local/bin/nodeln -s /your/nodejs/dir/bin/npm /usr/local/bin/npm 将上面路径替换成你的nodejs真实路径，也可以直接将node可执行文件拷贝到/usr/local/bin目录下。 安装hexo1sudo npm install -g hexo-cli 安装hexo需要使用npm包管理器来安装，安装好后运行hexo命令，控制台提示说找不到该命令，让我郁闷了一哈，后来才发现hexo命令在/your/nodejs/dir/bin/目录下，还是老办法，设置软链接。 1ln -s /your/nodejs/dir/bin/hexo /usr/local/bin/hexo 建立站点1hexo init blog blog目录就是你的站点根目录，目录里面的_config.yml是站点配置文件，后面还会说到主题配置文件，每一个主题都用一个_config.yml文件，不要搞混了，到目前为止博客环境已经搭建完成。 本地调试博客搭建好了，没有run起来感觉心里是虚的，接下来我们把博客run起来看，首先生成静态页面。 1hexo generate(可以缩写成g) 启动本地服务，在浏览器输入http://localhost:4000就可以看效果了。 1hexo server(可以缩写成s) 看到上图出现，说明搭建博客成功。 配置githubhexo生成的静态页面是要上传到github上面的，所以需要配置好github，首先需要在github上建立一个仓库，仓库名格式是username.github.io，比如我的就是chxuan.github.io，不要乱取，不然配置不成功。之后编辑站点配置文件在末尾加入。 1234deploy: type: git repo: https://github.com/chxuan/chxuan.github.io.git branch: master repo行需要替换成你自己的仓库路径，保存之后运行如下命令。 12npm install hexo-deployer-git --savehexo deploy(可以缩写成d) 至此hexo已经关联好了github，在浏览器输入http://username.github.io/，比如我的是http://chxuan.github.io/就可以浏览了，github默认提供的是一个二级域名，你也可去阿里云购买域名，替换掉github提供的。 发表文章1234hexo new "xxxxxxxx" hexo cleanhexo generate(可以缩写成g)hexo deploy(可以缩写成d) 以上是发表文章的步骤，执行hexo new 之后会在站点目录的source/_posts/目录下生成.md结尾的博客，我用的Cmd Mardown来写博客的。 创建一个标签页1234hexo new page "about" hexo cleanhexo generate(可以缩写成g)hexo deploy(可以缩写成d) 上面创建了一个关于我的标签页并部署到github服务器上。 设置主题我使用的是NexT主题，目前github星星数最多的一个主题，主题界面一般，主要是文档齐全吧，所以很受人们欢迎，我也建议新手使用该主题，主题配置参考NexT官方文档。 集成第三方插件若想要别人评论你的博客、查看访问次数、搜索博客等功能需要第三方插件支持，你可以参考NexT官方文档。 多电脑发布博客公司电脑和家用电脑都可以写博客，当环境搭建好后，怎么进行文章同步呢，我使用的是github，我在github上创建了一个名为blog的仓库用来存放博客文件，你需要将本地站点blog目录进行hexo clean之后，hexo clean执行过后就是删除public里面生成的静态页面等操作，将剩下的文件放入github同步就可以了。 参考文章 hexo官方文档 NexT主题官方文档]]></content>
    </entry>

    
  
  
</search>
