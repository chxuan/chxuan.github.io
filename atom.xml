<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chxuan&#39;s Notes</title>
  <subtitle>Keep It Simple, Stupid.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-27T00:57:23.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chxuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用方便的单例类</title>
    <link href="http://yoursite.com/2016/11/27/%E4%BD%BF%E7%94%A8%E6%96%B9%E4%BE%BF%E7%9A%84%E5%8D%95%E4%BE%8B%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/11/27/使用方便的单例类/</id>
    <published>2016-11-27T00:53:51.000Z</published>
    <updated>2016-11-27T00:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/11/singleton.jpg" alt="此处输入图片的描述"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在软件开发中会经常用到设计模式，其中运用的最为广泛的设计模式就是单例，下面是实现单例类的代码。</p>
<a id="more"></a>
<h2 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> singleton</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	singleton() = <span class="keyword">delete</span>;</div><div class="line">	<span class="keyword">virtual</span> ~singleton() = <span class="keyword">delete</span>;</div><div class="line">	singleton(<span class="keyword">const</span> singleton&amp;) = <span class="keyword">delete</span>;</div><div class="line">	singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> singleton&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div><div class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">get_instance</span><span class="params">(Args&amp;&amp;... args)</span></span></div><div class="line">	&#123;</div><div class="line">	    <span class="comment">// C++11保证单例的线程安全</span></div><div class="line">		<span class="keyword">static</span> T t&#123; <span class="built_in">std</span>::forward&lt;Args&gt;(args)... &#125;;</div><div class="line">		<span class="keyword">return</span> t;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SINGLETON(class_name) \</span></div><div class="line">public: \</div><div class="line">friend class singleton<span class="meta-string">&lt;class_name&gt;</span>; \</div><div class="line">using singleton = singleton<span class="meta-string">&lt;class_name&gt;</span>; \</div><div class="line">private: \</div><div class="line">virtual ~class_name() &#123;&#125; \</div><div class="line">class_name(const class_name&amp;) = delete; \</div><div class="line">class_name&amp; operator=(const class_name&amp;) = delete; \</div><div class="line">public:</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"singleton.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> test</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 只需要加入一句代码，就可以将test类变为单例类</span></div><div class="line">	DEFINE_SINGLETON(test);</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	test() = <span class="keyword">default</span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> test2</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 只需要加入一句代码，就可以将test2类变为单例类</span></div><div class="line">	DEFINE_SINGLETON(test2);</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	test2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str) : str_(str) &#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> str_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 没有参数的单例</span></div><div class="line">	test::singleton::get_instance().print();</div><div class="line">	<span class="comment">// 带有参数的单例</span></div><div class="line">	test2::singleton::get_instance(<span class="string">"nihao"</span>).print();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chxuan/images/master/blog/2016/11/singleton.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们在软件开发中会经常用到设计模式，其中运用的最为广泛的设计模式就是单例，下面是实现单例类的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
      <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
      <category term="单例" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>好用的http client库CPP REST SDK</title>
    <link href="http://yoursite.com/2016/11/01/%E5%A5%BD%E7%94%A8%E7%9A%84http%20client%E5%BA%93CPP%20REST%20SDK/"/>
    <id>http://yoursite.com/2016/11/01/好用的http client库CPP REST SDK/</id>
    <published>2016-11-01T14:05:41.000Z</published>
    <updated>2016-11-26T15:14:00.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/11/cpprestsdk.jpg" alt="此处输入图片的描述"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C++中http client库本身就少，好用的就更少了，在了解微软开源的<a href="https://github.com/Microsoft/cpprestsdk" target="_blank" rel="external">CPP REST SDK</a>库之前，我知道的C++ http client库有<a href="https://curl.haxx.se/" target="_blank" rel="external">libcurl</a>（这个是C语言的），Qt的<a href="http://doc.qt.io/qt-5/qnetworkaccessmanager.html" target="_blank" rel="external">QNetworkAccessManager</a>，还有VC++ http client，Qt的QNetworkAccessManager库我在开发<a href="https://github.com/chxuan/CZPlayer" target="_blank" rel="external">CZPlayer</a>的时候用来下载过音乐、专辑图片和歌词，不得不说Qt提供的API还是比较好用的，如果不涉及界面开发，难道我们在linux上就只能用libcurl，在windows上就用VC++的http client？答案是否定的，在绝望之际CPP REST SDK出现在我的眼前，CPP REST SDK是微软开源的基于PPL的异步http client，网络层使用的是Boost.Asio，跨平台，并且支持json解析，在使用CPP REST SDK之前要确保你已经安装了boost和openssl，下面是微软官方提供的例子。</p>
<a id="more"></a>
<h2 id="微软官方例子"><a href="#微软官方例子" class="headerlink" title="微软官方例子"></a>微软官方例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpprest/http_client.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cpprest/filestream.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> utility;                    <span class="comment">// Common utilities like string conversions</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> web;                        <span class="comment">// Common features like URIs.</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> web::http;                  <span class="comment">// Common HTTP functionality</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> web::http::client;          <span class="comment">// HTTP client features</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> concurrency::streams;       <span class="comment">// Asynchronous streams</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> fileStream = <span class="built_in">std</span>::make_shared&lt;ostream&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// Open stream to output file.</span></div><div class="line">    pplx::task&lt;<span class="keyword">void</span>&gt; requestTask = fstream::open_ostream(U(<span class="string">"results.html"</span>)).then([=](ostream outFile)</div><div class="line">    &#123;</div><div class="line">        *fileStream = outFile;</div><div class="line"></div><div class="line">        <span class="comment">// Create http_client to send the request.</span></div><div class="line">        http_client client(U(<span class="string">"http://www.bing.com/"</span>));</div><div class="line"></div><div class="line">        <span class="comment">// Build request URI and start the request.</span></div><div class="line">        uri_builder builder(U(<span class="string">"/search"</span>));</div><div class="line">        builder.append_query(U(<span class="string">"q"</span>), U(<span class="string">"cpprestsdk github"</span>));</div><div class="line">        <span class="keyword">return</span> client.request(methods::GET, builder.to_string());</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// Handle response headers arriving.</span></div><div class="line">    .then([=](http_response response)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Received response status code:%u\n"</span>, response.status_code());</div><div class="line"></div><div class="line">        <span class="comment">// Write response body into the file.</span></div><div class="line">        <span class="keyword">return</span> response.body().read_to_end(fileStream-&gt;streambuf());</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// Close the file stream.</span></div><div class="line">    .then([=](<span class="keyword">size_t</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> fileStream-&gt;close();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// Wait for all the outstanding I/O to complete and handle any exceptions</span></div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        requestTask.wait();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Error exception:%s\n"</span>, e.what());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子主要内容是访问一个网站并将该内容保存在results.html里面，这里用到了微软自家的PPL并行计算库（还有一个是英特尔的TBB），该例子使用lambda表达式作为异步回调的handler，打开文件流、请求、回应和关闭文件流都是异步的，为了方便起见，我们将该例子改为同步方式。</p>
<h2 id="使用同步方式"><a href="#使用同步方式" class="headerlink" title="使用同步方式"></a>使用同步方式</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">auto fileStream = std::make_shared&lt;ostream&gt;();</div><div class="line">ostream outFile = fstream::open_ostream(U("results.html")).get();</div><div class="line">*fileStream = outFile;</div><div class="line"></div><div class="line">// Create http_client to send the request.</div><div class="line">http_client client(U("http://www.bing.com/"));</div><div class="line"></div><div class="line">// Build request URI and start the request.</div><div class="line">uri_builder builder(U("/search"));</div><div class="line">builder.append_query(U("q"), U("cpprestsdk github"));</div><div class="line">http_response response = client.request(methods::GET, builder.to_string()).get();</div><div class="line">// Write response body into the file.</div><div class="line">response.body().read_to_end(fileStream-&gt;streambuf()).get();</div><div class="line">fileStream-&gt;close().get();</div></pre></td></tr></table></figure>
<p>使用同步方式的代码比较清晰，可以看到每一个函数调用后面都会调用get函数，因为CPP REST SDK是基于PPL的，所以在request、read_to_end、close等函数调用后都会返回一个Task对象，而Task里面的get和wait函数是等待任务执行完成。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>我之前在看别人博客的时候看到每一篇博客前都有一副图，看起来比较好看，听博主讲他是使用bing的每日一图，后来我也效仿，我在主题之家找到了自己比较喜欢的图片，最开始自己写博客的时候都是直接去主题之家一页一页的找看，然后再下载图片，写了几篇博客之后感觉每次都要去下载图片感觉有点low，所以我决定直接将主题之家的某类型的图片都下载下来，这样选图片就方便多了，下面是我在主题之家抓图的代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &lt;memory&gt;</div><div class="line">#include &lt;regex&gt;</div><div class="line">#include &lt;cpprest/http_client.h&gt;</div><div class="line">#include &lt;cpprest/filestream.h&gt;</div><div class="line">#include &lt;cpprest/containerstream.h&gt;</div><div class="line"></div><div class="line">// 请求并解析url</div><div class="line">bool get_result(const std::string&amp; url, const std::string&amp; pattern, std::vector&lt;std::string&gt;&amp; vec)</div><div class="line">&#123;</div><div class="line">	try</div><div class="line">	&#123;</div><div class="line">		web::http::client::http_client client(web::uri(utility::conversions::to_string_t(url)));</div><div class="line">		web::http::http_response response = client.request(web::http::methods::GET).get();</div><div class="line"></div><div class="line">		concurrency::streams::stringstreambuf buffer;</div><div class="line">		response.body().read_to_end(buffer).get();</div><div class="line">		std::string&amp; str = buffer.collection();</div><div class="line">        </div><div class="line">        // 使用C++11提供的正则表达式库</div><div class="line">		std::regex r(pattern);</div><div class="line">		for (std::sregex_iterator iter(str.begin(), str.end(), r), end; iter != end; ++iter)</div><div class="line">		&#123;</div><div class="line">			std::cout &lt;&lt; iter-&gt;str() &lt;&lt; std::endl;</div><div class="line">			vec.emplace_back(iter-&gt;str());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	catch (std::exception&amp; e)</div><div class="line">	&#123;</div><div class="line">		std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取图片</div><div class="line">bool get_result(const std::string&amp; url, std::string&amp; picture)</div><div class="line">&#123;</div><div class="line">	try</div><div class="line">	&#123;</div><div class="line">		web::http::client::http_client client(web::uri(utility::conversions::to_string_t(url)));</div><div class="line">		web::http::http_response response = client.request(web::http::methods::GET).get();</div><div class="line"></div><div class="line">		concurrency::streams::stringstreambuf buffer;</div><div class="line">		response.body().read_to_end(buffer).get();</div><div class="line">		picture = buffer.collection();</div><div class="line">	&#125;</div><div class="line">	catch (std::exception&amp; e)</div><div class="line">	&#123;</div><div class="line">		std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 保存图片</div><div class="line">bool write_to_file(const std::string&amp; file_path, const std::string&amp; data)</div><div class="line">&#123;</div><div class="line">	try</div><div class="line">	&#123;</div><div class="line">		std::ofstream file;</div><div class="line">		file.open(file_path, std::ios::out | std::ios::binary);</div><div class="line">		if (!file.good())</div><div class="line">		&#123;</div><div class="line">			return false;</div><div class="line">		&#125;</div><div class="line">		file.write(data.c_str(), data.size());</div><div class="line">		file.close();</div><div class="line">	&#125;</div><div class="line">	catch (std::exception&amp; e)</div><div class="line">	&#123;</div><div class="line">		std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    // [1] 请求每一页，将子页面的url保存在sub_url_vec里面</div><div class="line">	std::vector&lt;std::string&gt; sub_url_vec;</div><div class="line">	std::string pattern = "/desk/[0-9]+.htm";</div><div class="line">	for (int i = 1; i &lt;= 32; ++i)</div><div class="line">	&#123;</div><div class="line">		// 创意主题</div><div class="line">		std::string url = "http://www.51ztzj.com/dbizhi/category_27_" + std::to_string(i) + ".htm#content_anchor";</div><div class="line">		std::cout &lt;&lt; "Start get " &lt;&lt; i &lt;&lt; " page, url: " &lt;&lt; url &lt;&lt; std::endl;</div><div class="line">		// 请求并解析url</div><div class="line">		if (!get_result(url, pattern, sub_url_vec))</div><div class="line">		&#123;</div><div class="line">			std::cout &lt;&lt; "Get " &lt;&lt; i &lt;&lt; " page failed" &lt;&lt; std::endl;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// 最终的图片url：http://img.51ztzj.com//upload/image/20130220/2013022014_670x419.jpg</div><div class="line">	// [2] 将子页面的图片url解析出来放入picture_url_vec</div><div class="line">	std::vector&lt;std::string&gt; picture_url_vec;</div><div class="line">	pattern = "http://img.51ztzj.com//upload/image/.+/.+_670x419.jpg";</div><div class="line">	for (std::size_t i = 0; i &lt; sub_url_vec.size(); ++i)</div><div class="line">	&#123;</div><div class="line">		std::string url = "http://www.51ztzj.com" + sub_url_vec[i];</div><div class="line">		std::cout &lt;&lt; "Start get " &lt;&lt; i + 1 &lt;&lt; " sub page, url: " &lt;&lt; url &lt;&lt; std::endl;</div><div class="line">		// 请求并解析url</div><div class="line">		if (!get_result(url, pattern, picture_url_vec))</div><div class="line">		&#123;</div><div class="line">			std::cout &lt;&lt; "Get " &lt;&lt; i + 1 &lt;&lt; " sub page failed" &lt;&lt; std::endl;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    // [3] 最后遍历picture_url_vec，然后一个一个的下载图片</div><div class="line">	for (std::size_t i = 0; i &lt; picture_url_vec.size(); ++i)</div><div class="line">	&#123;</div><div class="line">		std::cout &lt;&lt; "Start download " &lt;&lt; i + 1 &lt;&lt; " picture, url: " &lt;&lt; picture_url_vec[i] &lt;&lt; std::endl;</div><div class="line">		std::string picture;</div><div class="line">		// 获取图片</div><div class="line">		if (!get_result(picture_url_vec[i], picture))</div><div class="line">		&#123;</div><div class="line">			std::cout &lt;&lt; "Download " &lt;&lt; i + 1 &lt;&lt; " picture failed" &lt;&lt; std::endl;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		std::string file_path = "./download/" + std::to_string(i) + ".jpg";</div><div class="line">		// 保存图片</div><div class="line">		if (!write_to_file(file_path, picture))</div><div class="line">		&#123;</div><div class="line">			std::cout &lt;&lt; "Write to file failed: " &lt;&lt; i + 1 &lt;&lt; std::endl;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chxuan/images/master/blog/2016/11/cpprestsdk.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;C++中http client库本身就少，好用的就更少了，在了解微软开源的&lt;a href=&quot;https://github.com/Microsoft/cpprestsdk&quot;&gt;CPP REST SDK&lt;/a&gt;库之前，我知道的C++ http client库有&lt;a href=&quot;https://curl.haxx.se/&quot;&gt;libcurl&lt;/a&gt;（这个是C语言的），Qt的&lt;a href=&quot;http://doc.qt.io/qt-5/qnetworkaccessmanager.html&quot;&gt;QNetworkAccessManager&lt;/a&gt;，还有VC++ http client，Qt的QNetworkAccessManager库我在开发&lt;a href=&quot;https://github.com/chxuan/CZPlayer&quot;&gt;CZPlayer&lt;/a&gt;的时候用来下载过音乐、专辑图片和歌词，不得不说Qt提供的API还是比较好用的，如果不涉及界面开发，难道我们在linux上就只能用libcurl，在windows上就用VC++的http client？答案是否定的，在绝望之际CPP REST SDK出现在我的眼前，CPP REST SDK是微软开源的基于PPL的异步http client，网络层使用的是Boost.Asio，跨平台，并且支持json解析，在使用CPP REST SDK之前要确保你已经安装了boost和openssl，下面是微软官方提供的例子。&lt;/p&gt;
    
    </summary>
    
      <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
      <category term="cpprestsdk" scheme="http://yoursite.com/tags/cpprestsdk/"/>
    
      <category term="http client" scheme="http://yoursite.com/tags/http-client/"/>
    
      <category term="PPL" scheme="http://yoursite.com/tags/PPL/"/>
    
  </entry>
  
  <entry>
    <title>让boost.variant支持lambda表达式访问</title>
    <link href="http://yoursite.com/2016/10/29/%E8%AE%A9boost.variant%E6%94%AF%E6%8C%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BF%E9%97%AE/"/>
    <id>http://yoursite.com/2016/10/29/让boost.variant支持lambda表达式访问/</id>
    <published>2016-10-29T13:13:43.000Z</published>
    <updated>2016-11-26T15:14:00.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/variant2.jpg" alt="此处输入图片的描述"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前写个过一篇博客叫<a href="http://chengxuan.me/2016/10/26/%E6%B5%85%E8%B0%88boost.variant%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="external">《浅谈boost.variant的几种访问方式》</a>，里面讲到了可以通过访问者方式来获取variant的值，但是在重载函数<code>operator()</code>里面只能够获取variant的值，如果要捕获外部变量或调用外部函数比较麻烦，那么有没有一种方法来简化variant的访问呢？当然有，下面我们让variant支持lambda表达式访问(个人博客也发表了<a href="http://chengxuan.me/2016/10/29/%E8%AE%A9boost.variant%E6%94%AF%E6%8C%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BF%E9%97%AE/" target="_blank" rel="external">《让boost.variant支持lambda表达式访问》</a>)。</p>
<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;utility&gt;</div><div class="line">#include &lt;type_traits&gt;</div><div class="line">#include &lt;boost/variant.hpp&gt;</div><div class="line"></div><div class="line">template&lt;typename Function, typename... Args&gt;</div><div class="line">struct make_overload_impl : make_overload_impl&lt;Function&gt;::type, </div><div class="line">                            make_overload_impl&lt;Args...&gt;::type</div><div class="line">&#123;</div><div class="line">    using type = make_overload_impl;</div><div class="line">    using make_overload_impl&lt;Function&gt;::type::operator();</div><div class="line">    using make_overload_impl&lt;Args...&gt;::type::operator();</div><div class="line">    constexpr explicit make_overload_impl(Function&amp;&amp; func, Args&amp;&amp;... args)</div><div class="line">        : make_overload_impl&lt;Function&gt;::type(std::forward&lt;Function&gt;(func)),</div><div class="line">        make_overload_impl&lt;Args...&gt;::type(std::forward&lt;Args&gt;(args)...)</div><div class="line">    &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template&lt;typename Function&gt;</div><div class="line">struct make_overload_impl&lt;Function&gt;</div><div class="line">&#123;</div><div class="line">    using type = Function;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template&lt;typename Return, typename... Args&gt;</div><div class="line">struct make_overload_impl&lt;Return(*)(Args...)&gt;</div><div class="line">&#123;</div><div class="line">    using type = make_overload_impl;</div><div class="line">    using Function = Return(*)(Args...);</div><div class="line">    constexpr explicit make_overload_impl(const Function&amp;&amp; func) : _func(func) &#123;&#125;</div><div class="line">    constexpr Return operator()(Args&amp;&amp;... args) const</div><div class="line">    &#123;</div><div class="line">        return _func(std::forward&lt;Args&gt;(args)...);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    Function _func;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct make_overload</div><div class="line">&#123;</div><div class="line">    template&lt;typename... Function, typename Overload = </div><div class="line">        typename make_overload_impl&lt;typename std::decay&lt;Function&gt;::type...&gt;::type&gt;</div><div class="line">    constexpr Overload operator()(Function&amp;&amp;... func) const</div><div class="line">    &#123;</div><div class="line">        return Overload(std::forward&lt;Function&gt;(func)...);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template&lt;typename... Args&gt;</div><div class="line">auto make_visitor(Args&amp;&amp;... args)</div><div class="line">&#123;</div><div class="line">    return make_overload()(std::forward&lt;Args&gt;(args)...);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    auto visitor = make_visitor</div><div class="line">    (</div><div class="line">        [](int&amp; i) &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125;,</div><div class="line">        [](std::string&amp; i) &#123; std::cout &lt;&lt; i &lt;&lt; std::endl; &#125;</div><div class="line">    );</div><div class="line">    boost::variant&lt;int, std::string&gt; v;</div><div class="line">    v = "Hello world";</div><div class="line">    boost::apply_visitor(visitor, v);</div><div class="line">    v = 100;</div><div class="line">    boost::apply_visitor(visitor, v);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该代码也上传到了我的<a href="https://github.com/chxuan/samples/tree/master/variant_visitor" target="_blank" rel="external">github</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://purecpp.org/?p=982" target="_blank" rel="external">让BOOST.VARIANT的VISIT支持LAMBDA</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/variant2.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前写个过一篇博客叫&lt;a href=&quot;http://chengxuan.me/2016/10/26/%E6%B5%85%E8%B0%88boost.variant%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/&quot;&gt;《浅谈boost.variant的几种访问方式》&lt;/a&gt;，里面讲到了可以通过访问者方式来获取variant的值，但是在重载函数&lt;code&gt;operator()&lt;/code&gt;里面只能够获取variant的值，如果要捕获外部变量或调用外部函数比较麻烦，那么有没有一种方法来简化variant的访问呢？当然有，下面我们让variant支持lambda表达式访问(个人博客也发表了&lt;a href=&quot;http://chengxuan.me/2016/10/29/%E8%AE%A9boost.variant%E6%94%AF%E6%8C%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BF%E9%97%AE/&quot;&gt;《让boost.variant支持lambda表达式访问》&lt;/a&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="boost" scheme="http://yoursite.com/categories/boost/"/>
    
    
      <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
      <category term="boost" scheme="http://yoursite.com/tags/boost/"/>
    
      <category term="variant" scheme="http://yoursite.com/tags/variant/"/>
    
      <category term="lambda" scheme="http://yoursite.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>浅谈boost.variant的几种访问方式</title>
    <link href="http://yoursite.com/2016/10/26/%E6%B5%85%E8%B0%88boost.variant%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/10/26/浅谈boost.variant的几种访问方式/</id>
    <published>2016-10-26T14:56:23.000Z</published>
    <updated>2016-11-26T15:14:00.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/variant.jpg" alt="此处输入图片的描述"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>variant类型在C++14并没有加入，在<a href="http://en.cppreference.com/w/" target="_blank" rel="external">cppreference</a>网站上可以看到该类型将会在C++17加入，若想在不支持C++17的编译器上使用variant类型，我们可以通过boost的variant类型，variant类型可以表示任意一种类型和any类型有些相似，但还是有些区别，比如说variant支持的类型需提前定义，而any类型不需要，获取any类型的值需要给出原始类型，然而variant类型支持多种方式访问，其中一种就是通过访问者模式来访问，是不需要给出原始类型的，下面将浅谈variant的几种访问方式(个人博客也发表了<a href="http://chengxuan.me/2016/10/26/%E6%B5%85%E8%B0%88boost.variant%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/" target="_blank" rel="external">《浅谈boost.variant的几种访问方式》</a>)。</p>
<a id="more"></a>
<h2 id="使用boost-get"><a href="#使用boost-get" class="headerlink" title="使用boost::get"></a>使用boost::get</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boost::variant&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</div><div class="line">v = <span class="string">"Hello world"</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; boost::get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(v) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>使用boost::get来访问，需要给出原始类型，并且这样做不安全，若类型错误，程序将会抛出异常。</p>
<h2 id="使用RTTI"><a href="#使用RTTI" class="headerlink" title="使用RTTI"></a>使用RTTI</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">var_print</span><span class="params">(boost::variant&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; v)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (v.type() == <span class="keyword">typeid</span>(<span class="keyword">int</span>))  </div><div class="line">    &#123;  </div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; boost::get&lt;<span class="keyword">int</span>&gt;(v) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v.type() == <span class="keyword">typeid</span>(<span class="built_in">std</span>::<span class="built_in">string</span>))  </div><div class="line">    &#123;  </div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; boost::get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(v) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// Else do nothing</span></div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    boost::variant&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</div><div class="line">    v = <span class="string">"Hello world"</span>;  </div><div class="line">    var_print(v);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用RTTI技术可以避免类型访问错误而程序异常的情况，但是这样做有点不优雅，每增加一个类型，都需要修改if-else结构，并且使用RTTI会对程序性能有一定影响。</p>
<h2 id="使用访问者模式"><a href="#使用访问者模式" class="headerlink" title="使用访问者模式"></a>使用访问者模式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> var_visitor : <span class="keyword">public</span> boost::static_visitor&lt;<span class="keyword">void</span>&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    boost::variant&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</div><div class="line">    v = <span class="string">"Hello world"</span>;  </div><div class="line">    boost::apply_visitor(var_visitor(), v);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用该模式，需要定义一个类并继承于boost::static_visitor，在类里面需要重载<code>()</code>操作符，通过boost::apply_visitor来访问原始类型的值，这样做还是有些繁琐，每增加一个类型，都需要在var_visitor里面增加一个函数，但比使用RTTI里面的修改if-else结构好得多，因为使用访问者模式至少是遵循开放-封闭原则的，即对写开放，对修改封闭。</p>
<h2 id="使用模板函数"><a href="#使用模板函数" class="headerlink" title="使用模板函数"></a>使用模板函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> var_visitor : <span class="keyword">public</span> boost::static_visitor&lt;<span class="keyword">void</span>&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T&amp; i)</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    boost::variant&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</div><div class="line">    v = <span class="string">"Hello world"</span>;  </div><div class="line">    boost::apply_visitor(var_visitor(), v);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将<code>operator()</code>改成了模板函数的好处就是不用关心variant支持多少类型。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.boost.org/doc/libs/1_62_0/doc/html/variant/tutorial.html" target="_blank" rel="external">boost官网</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/variant.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;variant类型在C++14并没有加入，在&lt;a href=&quot;http://en.cppreference.com/w/&quot;&gt;cppreference&lt;/a&gt;网站上可以看到该类型将会在C++17加入，若想在不支持C++17的编译器上使用variant类型，我们可以通过boost的variant类型，variant类型可以表示任意一种类型和any类型有些相似，但还是有些区别，比如说variant支持的类型需提前定义，而any类型不需要，获取any类型的值需要给出原始类型，然而variant类型支持多种方式访问，其中一种就是通过访问者模式来访问，是不需要给出原始类型的，下面将浅谈variant的几种访问方式(个人博客也发表了&lt;a href=&quot;http://chengxuan.me/2016/10/26/%E6%B5%85%E8%B0%88boost.variant%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/&quot;&gt;《浅谈boost.variant的几种访问方式》&lt;/a&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="boost" scheme="http://yoursite.com/categories/boost/"/>
    
    
      <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
      <category term="boost" scheme="http://yoursite.com/tags/boost/"/>
    
      <category term="variant" scheme="http://yoursite.com/tags/variant/"/>
    
  </entry>
  
  <entry>
    <title>使用C++11实现一个半同步半异步线程池</title>
    <link href="http://yoursite.com/2016/10/23/%E4%BD%BF%E7%94%A8C++11%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2016/10/23/使用C++11实现一个半同步半异步线程池/</id>
    <published>2016-10-22T23:47:44.000Z</published>
    <updated>2016-11-26T15:14:00.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/thread_pool.jpg" alt="此处输入图片的描述"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C++11之前我们使用线程需要系统提供API、posix线程库或者使用boost提供的线程库，C++11后就加入了跨平台的线程类std::thread，线程同步相关类std::mutex、std::lock_guard、std::condition_variable、std::atomic以及异步操作相关类std::async、std::future、std::promise等等，这使得我们编写跨平台的多线程程序变得容易，线程的一个高级应用就是线程池，使用线程池可以充分利用多核CPU的并行计算能力，以及避免了使用单个线程的创建和销毁的开销，所以线程池在实际项目中用的很广泛，很多RPC框架都是用了线程池来处理事务，比如说<a href="https://github.com/apache/thrift" target="_blank" rel="external">Thrift</a>，<a href="https://github.com/chxuan/easyrpc" target="_blank" rel="external">easyrpc</a>等等，接下来我们将使用C++11来实现一个通用的半同步半异步线程池(个人博客也发表了<a href="http://chengxuan.me/2016/10/23/%E4%BD%BF%E7%94%A8C++11%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/" target="_blank" rel="external">《使用C++11实现一个半同步半异步线程池》</a>)。</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一个半同步半异步线程池分为三层。</p>
<ol>
<li>同步服务层：它处理来自上层的任务请求,上层的请求可能是并发的,这些请求不是马上就会被处理的,而是将这些任务放到一个同步排队层中,等待处理。</li>
<li>同步排队层: 来自上层的任务请求都会加到排队层中等待处理，排队层实际就是一个std::queue。</li>
<li>异步服务层: 这一层中会有多个线程同时处理排队层中的任务,异步服务层从同步排队层中取出任务并行的处理。</li>
</ol>
<p>这三个层次之间需要使用std::mutex、std::condition_variable来进行事件同步，线程池的实现代码如下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div></pre></td><td class="code"><pre><div class="line">#ifndef _THREADPOOL_H</div><div class="line">#define _THREADPOOL_H</div><div class="line"></div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;mutex&gt;</div><div class="line">#include &lt;memory&gt;</div><div class="line">#include &lt;functional&gt;</div><div class="line">#include &lt;condition_variable&gt;</div><div class="line">#include &lt;atomic&gt;</div><div class="line">#include &lt;type_traits&gt;</div><div class="line"></div><div class="line">static const std::size_t max_task_quque_size = 100000;</div><div class="line">static const std::size_t max_thread_size = 30;</div><div class="line"></div><div class="line">class thread_pool</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    using work_thread_ptr = std::shared_ptr&lt;std::thread&gt;;</div><div class="line">    using task_t = std::function&lt;void()&gt;; </div><div class="line"></div><div class="line">    explicit thread_pool() : _is_stop_threadpool(false) &#123;&#125;</div><div class="line"></div><div class="line">    ~thread_pool()</div><div class="line">    &#123;</div><div class="line">        stop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void init_thread_num(std::size_t num)</div><div class="line">    &#123;</div><div class="line">        if (num &lt;= 0 || num &gt; max_thread_size)</div><div class="line">        &#123;</div><div class="line">            std::string str = "Number of threads in the range of 1 to " + std::to_string(max_thread_size);</div><div class="line">            throw std::invalid_argument(str);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (std::size_t i = 0; i &lt; num; ++i)</div><div class="line">        &#123;</div><div class="line">            work_thread_ptr t = std::make_shared&lt;std::thread&gt;(std::bind(&amp;thread_pool::run_task, this));</div><div class="line">            _thread_vec.emplace_back(t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 支持普通全局函数、静态函数、以及lambda表达式</div><div class="line">    template&lt;typename Function, typename... Args&gt;</div><div class="line">    void add_task(const Function&amp; func, Args... args)</div><div class="line">    &#123;</div><div class="line">        if (!_is_stop_threadpool)</div><div class="line">        &#123;</div><div class="line">            // 用lambda表达式来保存函数地址和参数</div><div class="line">            task_t task = [&amp;func, args...]&#123; return func(args...); &#125;;</div><div class="line">            add_task_impl(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 支持函数对象（仿函数）</div><div class="line">    template&lt;typename Function, typename... Args&gt;</div><div class="line">    typename std::enable_if&lt;std::is_class&lt;Function&gt;::value&gt;::type add_task(Function&amp; func, Args... args)</div><div class="line">    &#123;</div><div class="line">        if (!_is_stop_threadpool)</div><div class="line">        &#123;</div><div class="line">            task_t task = [&amp;func, args...]&#123; return func(args...); &#125;;</div><div class="line">            add_task_impl(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 支持类成员函数</div><div class="line">    template&lt;typename Function, typename Self, typename... Args&gt;</div><div class="line">    void add_task(const Function&amp; func, Self* self, Args... args)</div><div class="line">    &#123;</div><div class="line">        if (!_is_stop_threadpool)</div><div class="line">        &#123;</div><div class="line">            task_t task = [&amp;func, &amp;self, args...]&#123; return (*self.*func)(args...); &#125;;</div><div class="line">            add_task_impl(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void stop()</div><div class="line">    &#123;</div><div class="line">        // 保证terminate_all函数只被调用一次</div><div class="line">        std::call_once(_call_flag, [this]&#123; terminate_all(); &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    void add_task_impl(const task_t&amp; task)</div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            // 任务队列满了将等待线程池消费任务队列</div><div class="line">            std::unique_lock&lt;std::mutex&gt; locker(_task_queue_mutex);</div><div class="line">            while (_task_queue.size() == max_task_quque_size &amp;&amp; !_is_stop_threadpool)</div><div class="line">            &#123;</div><div class="line">                _task_put.wait(locker);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            _task_queue.emplace(std::move(task));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">       // 向任务队列插入了一个任务并提示线程池可以来取任务了</div><div class="line">        _task_get.notify_one();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void terminate_all()</div><div class="line">    &#123;</div><div class="line">        _is_stop_threadpool = true;</div><div class="line">        _task_get.notify_all();</div><div class="line"></div><div class="line">        for (auto&amp; iter : _thread_vec)</div><div class="line">        &#123;</div><div class="line">            if (iter != nullptr)</div><div class="line">            &#123;</div><div class="line">                if (iter-&gt;joinable())</div><div class="line">                &#123;</div><div class="line">                    iter-&gt;join();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        _thread_vec.clear();</div><div class="line"></div><div class="line">        clean_task_queue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void run_task()</div><div class="line">    &#123;</div><div class="line">        // 线程池循环取任务</div><div class="line">        while (true)</div><div class="line">        &#123;</div><div class="line">            task_t task = nullptr;</div><div class="line">            &#123;</div><div class="line">                // 任务队列为空将等待</div><div class="line">                std::unique_lock&lt;std::mutex&gt; locker(_task_queue_mutex);</div><div class="line">                while (_task_queue.empty() &amp;&amp; !_is_stop_threadpool)</div><div class="line">                &#123;</div><div class="line">                    _task_get.wait(locker);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (_is_stop_threadpool)</div><div class="line">                &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (!_task_queue.empty())</div><div class="line">                &#123;</div><div class="line">                    task = std::move(_task_queue.front());</div><div class="line">                    _task_queue.pop();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (task != nullptr)</div><div class="line">            &#123;</div><div class="line">                // 执行任务，并通知同步服务层可以向队列放任务了</div><div class="line">                task();</div><div class="line">                _task_put.notify_one();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void clean_task_queue()</div><div class="line">    &#123;</div><div class="line">        std::lock_guard&lt;std::mutex&gt; locker(_task_queue_mutex);</div><div class="line">        while (!_task_queue.empty())</div><div class="line">        &#123;</div><div class="line">            _task_queue.pop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">    std::vector&lt;work_thread_ptr&gt; _thread_vec;</div><div class="line">    std::condition_variable _task_put;</div><div class="line">    std::condition_variable _task_get;</div><div class="line">    std::mutex _task_queue_mutex;</div><div class="line">    std::queue&lt;task_t&gt; _task_queue;</div><div class="line">    std::atomic&lt;bool&gt; _is_stop_threadpool;</div><div class="line">    std::once_flag _call_flag;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"thread_pool.hpp"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_task</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Current thread id: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">", str: "</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">50</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Test</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> i)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test: "</span> &lt;&lt; str &lt;&lt; <span class="string">", i: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Test2</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> i)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test2: "</span> &lt;&lt; str &lt;&lt; <span class="string">", i: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    Test t;</div><div class="line">    Test2 t2;</div><div class="line">    thread_pool pool;</div><div class="line">    <span class="comment">// 启动10个线程</span></div><div class="line">    pool.init_thread_num(<span class="number">10</span>);</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Hello world"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 支持lambda表达式</span></div><div class="line">        pool.add_task([]&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello ThreadPool"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;);</div><div class="line">        <span class="comment">// 支持全局函数</span></div><div class="line">        pool.add_task(test_task, str);</div><div class="line">        <span class="comment">// 支持函数对象</span></div><div class="line">        pool.add_task(t2, str, i);</div><div class="line">        <span class="comment">// 支持类成员函数</span></div><div class="line">        pool.add_task(&amp;Test::print, &amp;t, str, i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.get();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"##############END###################"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试程序启动了十个线程并调用add_task函数加入了4000个任务，add_task支持普通全局函数、静态函数、类成员函数、函数对象（仿函数）以及lambda表达式，并且支持函数传入，该线程池的实现以及测试代码我已经放到了<a href="https://github.com/chxuan/samples/tree/master/thread_pool" target="_blank" rel="external">github</a>上。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入应用C++11–代码优化与工程级应用》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/thread_pool.jpg&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;C++11之前我们使用线程需要系统提供API、posix线程库或者使用boost提供的线程库，C++11后就加入了跨平台的线程类std::thread，线程同步相关类std::mutex、std::lock_guard、std::condition_variable、std::atomic以及异步操作相关类std::async、std::future、std::promise等等，这使得我们编写跨平台的多线程程序变得容易，线程的一个高级应用就是线程池，使用线程池可以充分利用多核CPU的并行计算能力，以及避免了使用单个线程的创建和销毁的开销，所以线程池在实际项目中用的很广泛，很多RPC框架都是用了线程池来处理事务，比如说&lt;a href=&quot;https://github.com/apache/thrift&quot;&gt;Thrift&lt;/a&gt;，&lt;a href=&quot;https://github.com/chxuan/easyrpc&quot;&gt;easyrpc&lt;/a&gt;等等，接下来我们将使用C++11来实现一个通用的半同步半异步线程池(个人博客也发表了&lt;a href=&quot;http://chengxuan.me/2016/10/23/%E4%BD%BF%E7%94%A8C++11%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0/&quot;&gt;《使用C++11实现一个半同步半异步线程池》&lt;/a&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="C++11" scheme="http://yoursite.com/categories/C-11/"/>
    
    
      <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>超级强大的vim配置(vimplus)</title>
    <link href="http://yoursite.com/2016/10/20/%E8%B6%85%E7%BA%A7%E5%BC%BA%E5%A4%A7%E7%9A%84vim%E9%85%8D%E7%BD%AE-vimplus/"/>
    <id>http://yoursite.com/2016/10/20/超级强大的vim配置-vimplus/</id>
    <published>2016-10-20T14:37:14.000Z</published>
    <updated>2016-11-26T15:14:00.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/main.png" alt="此处输入图片的描述"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vim和emacs是linux环境下的文本编辑利器，关于vim和emacs谁更优秀的话题从来没有断过，我在这里就不再评判了，vim是linux下的默认编辑器，学好了vim将会一生受用，我之前学vim是在网上找的一些资料，读博客之类的，使用了几年vim始终感觉没有什么大的进步，后来在vim官网看到vim书籍推荐，其中一本就是《vim实用技巧》，后来果断在京东上买了一本，除了宏相关的没怎么看以外，其他的都看了，加上自己的实际操作，感觉vim技术又上了一个层次，《vim实用技巧》是教会vimer怎么使用vim，使用vim写代码时，给vim装上一些插件，将会如虎添翼，后来我在网上找一些插件来安装，或者在github上搜索别人的vimrc，看别人装了什么插件，自己选择性的安装了一些，使用一段时间后感觉使用vim编辑代码就是一件非常愉快的事情，再加上我最近买的忍者二代机械键盘那简直写代码很带感啊，我最开始自己家的电脑上给vim装了很多插件，后来在公司又要重新搭建vim开发环境，感觉有点麻烦，后来又想有没有什么一键安装、部署之类的小程序，就可以傻瓜式的把开发环境给搭建起来不是很爽吗，<a href="https://github.com/chxuan/vimplus" target="_blank" rel="external">vimplus</a>就运运而生了，如果喜欢的朋友请不要吝啬，给个star，废话不多说，直接上安装步骤(个人博客也发表了<a href="http://chengxuan.me/2016/10/20/%E8%B6%85%E7%BA%A7%E5%BC%BA%E5%A4%A7%E7%9A%84vim%E9%85%8D%E7%BD%AE-vimplus/" target="_blank" rel="external">《超级强大的vim配置(vimplus)》</a>)。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/chxuan/vimplus.git</div><div class="line"><span class="built_in">cd</span> ./vimplus</div><div class="line">sudo ./install.sh</div></pre></td></tr></table></figure>
<p>现在vimplus支持ubuntu14.04之后的所有ubuntu 64位系列以及centos7 64位，运行<code>install.sh</code>脚本，你就可以一边喝咖啡，一遍看着屏幕刷刷刷的打印就安装部署好了开发环境了，整个过程大约持续40分钟，其中下载编译ycm耗费了大半时间，我有下载好了的<a href="http://pan.baidu.com/s/1kVdgsRl" target="_blank" rel="external">YouCompleteMe.tar.gz</a>，省得在github上去下载，很慢的，你懂的，若想要手动安装ycm，需要修改<code>vimplus</code>目录下的<code>.vimrc</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Plugin <span class="string">'Valloric/MatchTagAlways'</span></div><div class="line"><span class="comment">#Plugin 'Valloric/YouCompleteMe'</span></div><div class="line">Plugin <span class="string">'docunext/closetag.vim'</span></div></pre></td></tr></table></figure>
<p>将ycm插件那行注释掉，不然还会再去下载ycm，ycm可以最后等vimplus执行完成后再安装~~，接下来需要手动编译ycm。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> ~</div><div class="line">mv YouCompleteMe.tar.gz ~/.vim/bundle/</div><div class="line"><span class="built_in">cd</span> ~/.vim/bundle/</div><div class="line">tar -xvf YouCompleteMe.tar.gz</div><div class="line"><span class="built_in">cd</span> YouCompleteMe</div><div class="line">./install.py --clang-completer</div></pre></td></tr></table></figure>
<p>vimplus将自动安装一些软件，比如说。</p>
<ul>
<li>vim</li>
<li>g++ </li>
<li>ctags </li>
<li>cmake</li>
<li>python2</li>
<li>python3</li>
</ul>
<p>安装的插件我也部分列出来。</p>
<ul>
<li><a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="external">Vundle</a></li>
<li><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">YouCompleteMe</a></li>
<li><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="external">NerdTree</a></li>
<li><a href="https://github.com/scrooloose/nerdcommenter" target="_blank" rel="external">nerdcommenter</a></li>
<li><a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="external">Airline</a></li>
<li><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="external">auto-pairs</a></li>
<li><a href="https://github.com/vim-scripts/DoxygenToolkit.vim" target="_blank" rel="external">DoxygenToolkit</a></li>
<li><a href="https://github.com/ctrlpvim/ctrlp.vim" target="_blank" rel="external">ctrlp</a></li>
<li><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="external">tagbar</a></li>
<li><a href="https://github.com/ryanoasis/vim-devicons" target="_blank" rel="external">vim-devicons</a></li>
<li><a href="https://github.com/tpope/vim-surround" target="_blank" rel="external">vim-surround</a></li>
<li><a href="https://github.com/tpope/vim-commentary" target="_blank" rel="external">vim-commentary</a></li>
<li><a href="https://github.com/tpope/vim-repeat" target="_blank" rel="external">vim-repeat</a></li>
<li><a href="https://github.com/tpope/vim-endwise" target="_blank" rel="external">vim-endwise</a></li>
<li><a href="https://github.com/godlygeek/tabular" target="_blank" rel="external">tabular</a></li>
<li><a href="https://github.com/will133/vim-dirdiff" target="_blank" rel="external">vim-dirdiff</a></li>
<li><a href="https://github.com/gko/vim-coloresque" target="_blank" rel="external">vim-coloresque</a></li>
<li><a href="https://github.com/haya14busa/incsearch.vim" target="_blank" rel="external">incsearch.vim</a></li>
<li><a href="https://github.com/mhinz/vim-startify" target="_blank" rel="external">vim-startify</a></li>
<li><a href="https://github.com/chxuan/change-colorscheme" target="_blank" rel="external">change-colorscheme</a></li>
<li>etc…</li>
</ul>
<h2 id="配置YouCompleteMe"><a href="#配置YouCompleteMe" class="headerlink" title="配置YouCompleteMe"></a>配置YouCompleteMe</h2><p>到这一步，安装已经完成，你会发现<code>~</code>目录有两个文件，一个是vim的配置文件<code>.vimrc</code>，一个是YouCompleteMe的配置文件<code>[.ycm_extra_conf.py][25]</code>，一般来说建立一个main.cpp来写C、C++程序来说是没有问题的，都会有语法补全，当你需要写一些项目并涉及到第三方库时，就需要更改<code>[.ycm_extra_conf.py][26]</code>了，具体步骤如下。</p>
<ol>
<li>将.ycm_extra_conf.py拷贝的项目的根目录。</li>
<li>更改.ycm_extra_conf.py里面的<code>flags</code>变量，添加三方库路径和工程子目录路径。</li>
</ol>
<h2 id="使用vim-devicons"><a href="#使用vim-devicons" class="headerlink" title="使用vim-devicons"></a>使用vim-devicons</h2><p>桌面版linux使用<a href="https://github.com/ryanoasis/vim-devicons" target="_blank" rel="external">vim-devicons</a>插件会出现乱码，需要设置终端字体为<code>Droid Sans Mono for Powerline Nerd Font Complete</code>，使用xshell等工具连接服务器linux的用户就没有必要使用vim-devicons了，可以在插件目录将vim-devicons目录删除，不然会导致<code>NerdTree</code>的缩进有问题。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>vim的插件需要设置好了快捷键才会发挥它的威力，有些插件的快捷键可以查看各自官网，有些快捷键我自己改过的，下面罗列部分插件的快捷键。</p>
<ul>
<li>显示目录树 <code>&lt;F3&gt;</code></li>
<li>显示函数、变量、宏定义等 <code>&lt;F4&gt;</code></li>
<li>显示静态代码分析结果 <code>&lt;F5&gt;</code></li>
<li>.h .cpp 文件快速切换 <code>&lt;F2&gt;</code></li>
<li>转到申明 <code>&lt;, + u&gt;</code></li>
<li>转到定义 <code>&lt;, + i&gt;</code></li>
<li>打开包含文件 <code>&lt;, + o&gt;</code></li>
<li>Buffer切换 <code>&lt;Ctrl + P/Ctrl + N&gt;</code></li>
<li>光标位置切换 <code>&lt;Ctrl + O/Ctrl + I&gt;</code></li>
<li>模糊搜索文件 <code>&lt;Ctrl + f&gt;</code></li>
<li>Surround <code>&lt;ys{motion or text-object}{char}/cs{orig_char}{dest_char}/ds{char}&gt;</code></li>
<li>注释 <code>&lt;gcc/gcap/gc/,ca/,cA&gt;</code></li>
<li>DirDiff <code>:DirDiff &lt;dir1&gt; &lt;dir2&gt;</code></li>
<li>重复 <code>.</code></li>
<li>改变主题 <code>&lt;F10/F9&gt;</code></li>
</ul>
<h2 id="部分特性截图"><a href="#部分特性截图" class="headerlink" title="部分特性截图"></a>部分特性截图</h2><h3 id="语法补全"><a href="#语法补全" class="headerlink" title="语法补全"></a>语法补全</h3><p>YouCompleteMe就不用多说了，它通过clang编译器提供语法快速补全。<br><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/ycm.gif" alt="此处输入图片的描述"></p>
<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>ctrlp提供文件搜索，支持模糊查询。<br><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/ctrlp.png" alt="此处输入图片的描述"></p>
<h3 id="vim-airline"><a href="#vim-airline" class="headerlink" title="vim-airline"></a>vim-airline</h3><p>vim-airline提供漂亮的状态栏支持。<br><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/airline.gif" alt="此处输入图片的描述"></p>
<h3 id="vim-surround"><a href="#vim-surround" class="headerlink" title="vim-surround"></a>vim-surround</h3><p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/surround.gif" alt="此处输入图片的描述"></p>
<h3 id="vim-commentary"><a href="#vim-commentary" class="headerlink" title="vim-commentary"></a>vim-commentary</h3><p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/commentary.gif" alt="此处输入图片的描述"></p>
<h3 id="auto-pairs"><a href="#auto-pairs" class="headerlink" title="auto-pairs"></a>auto-pairs</h3><p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/auto-pairs.gif" alt="此处输入图片的描述"></p>
<h3 id="incsearch-vim"><a href="#incsearch-vim" class="headerlink" title="incsearch.vim"></a>incsearch.vim</h3><p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/incsearch.gif" alt="此处输入图片的描述"></p>
<h3 id="vim-devicons"><a href="#vim-devicons" class="headerlink" title="vim-devicons"></a>vim-devicons</h3><p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/devicons.png" alt="此处输入图片的描述"><br><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/devicons2.png" alt="此处输入图片的描述"><br><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/devicons3.png" alt="此处输入图片的描述"></p>
<h3 id="vim-coloresque"><a href="#vim-coloresque" class="headerlink" title="vim-coloresque"></a>vim-coloresque</h3><p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/colorsque.png" alt="此处输入图片的描述"></p>
<h3 id="vim-dirdiff"><a href="#vim-dirdiff" class="headerlink" title="vim-dirdiff"></a>vim-dirdiff</h3><p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/dirdiff.png" alt="此处输入图片的描述"></p>
<h3 id="vim-startify"><a href="#vim-startify" class="headerlink" title="vim-startify"></a>vim-startify</h3><p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/startify.png" alt="此处输入图片的描述"></p>
<h3 id="Change-the-colorscheme"><a href="#Change-the-colorscheme" class="headerlink" title="Change the colorscheme"></a>Change the colorscheme</h3><p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/change-colorscheme.gif" alt="此处输入图片的描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/main.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;vim和emacs是linux环境下的文本编辑利器，关于vim和emacs谁更优秀的话题从来没有断过，我在这里就不再评判了，vim是linux下的默认编辑器，学好了vim将会一生受用，我之前学vim是在网上找的一些资料，读博客之类的，使用了几年vim始终感觉没有什么大的进步，后来在vim官网看到vim书籍推荐，其中一本就是《vim实用技巧》，后来果断在京东上买了一本，除了宏相关的没怎么看以外，其他的都看了，加上自己的实际操作，感觉vim技术又上了一个层次，《vim实用技巧》是教会vimer怎么使用vim，使用vim写代码时，给vim装上一些插件，将会如虎添翼，后来我在网上找一些插件来安装，或者在github上搜索别人的vimrc，看别人装了什么插件，自己选择性的安装了一些，使用一段时间后感觉使用vim编辑代码就是一件非常愉快的事情，再加上我最近买的忍者二代机械键盘那简直写代码很带感啊，我最开始自己家的电脑上给vim装了很多插件，后来在公司又要重新搭建vim开发环境，感觉有点麻烦，后来又想有没有什么一键安装、部署之类的小程序，就可以傻瓜式的把开发环境给搭建起来不是很爽吗，&lt;a href=&quot;https://github.com/chxuan/vimplus&quot;&gt;vimplus&lt;/a&gt;就运运而生了，如果喜欢的朋友请不要吝啬，给个star，废话不多说，直接上安装步骤(个人博客也发表了&lt;a href=&quot;http://chengxuan.me/2016/10/20/%E8%B6%85%E7%BA%A7%E5%BC%BA%E5%A4%A7%E7%9A%84vim%E9%85%8D%E7%BD%AE-vimplus/&quot;&gt;《超级强大的vim配置(vimplus)》&lt;/a&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="vim" scheme="http://yoursite.com/categories/vim/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo+github搭建个人博客</title>
    <link href="http://yoursite.com/2016/10/19/%E4%BD%BF%E7%94%A8hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/10/19/使用hexo+github搭建个人博客/</id>
    <published>2016-10-19T09:24:04.000Z</published>
    <updated>2016-11-26T15:14:00.784Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/hexo.png" alt="此处输入图片的描述"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上大学期间都没有做笔记、写博客的习惯，工作以后学的东西多了，接触的东西多了，才发现做笔记是一件很重要的事情，做笔记可以将自己的想法、思路写下来，方便以后查阅，俗话说好记性不如键盘党，做笔记、写博客也可以让自己学会总结、学会分享，今年年初才开始使用cnblogs来写博客，账号已经申请了两年多了，大学期间一直没用，cnblogs写了一段时间发现网上一些大牛都有自己的博客，因为我比较喜欢折腾和装X，所以我也打算搭建一个博客，我不是做web方向的，也不懂jsp、asp.net、php（世界上最好的语言）、webpy等语言和技术（大学时学过，后来就忘了），之前我看到我同学基于<a href="https://cn.wordpress.org/" target="_blank" rel="external">WordPress</a>搭建了一个<a href="http://www.lampnick.com/" target="_blank" rel="external">博客</a>，这个需要数据库啊，服务器之类的，感觉有点麻烦，后来在网上查阅资料看到<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">hexo</a>、<a href="http://jekyll.com.cn/" target="_blank" rel="external">jekyll</a>配合github就可以用来搭建博客，github作为服务器这样还省去了租用服务器的费用，有人会问国内的<a href="https://coding.net/" target="_blank" rel="external">coding</a>也可以作为部署服务器啊，还快些，我只想说信仰不同，不相为谋，存储图片我也是用的github，没有用七牛的，最后我选择的hexo + github方案来制作个人博客，我是在ubuntu上搭建的，在windows和mac上搭建的朋友本篇博客还是有参考意义，下面是详细的制作过程(个人博客也发表了<a href="http://chengxuan.me/2016/10/19/%E4%BD%BF%E7%94%A8hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">《使用hexo+github搭建个人博客》</a>)。</p>
<a id="more"></a>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>部署服务器需要使用github，所以git成了必要工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>我直接在<a href="http://nodejs.cn/" target="_blank" rel="external">node.js</a>的<a href="http://nodejs.cn/" target="_blank" rel="external">官网</a>下载二进制包来安装的，下载过后，解压，设置软链接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ln <span class="_">-s</span> /your/nodejs/dir/bin/node /usr/<span class="built_in">local</span>/bin/node</div><div class="line">ln <span class="_">-s</span> /your/nodejs/dir/bin/npm /usr/<span class="built_in">local</span>/bin/npm</div></pre></td></tr></table></figure>
<p>将上面路径替换成你的nodejs真实路径，也可以直接将node可执行文件拷贝到<code>/usr/local/bin</code>目录下。</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>安装hexo需要使用npm包管理器来安装，安装好后运行hexo命令，控制台提示说找不到该命令，让我郁闷了一哈，后来才发现hexo命令在<code>/your/nodejs/dir/bin/</code>目录下，还是老办法，设置软链接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln <span class="_">-s</span> /your/nodejs/dir/bin/hexo /usr/<span class="built_in">local</span>/bin/hexo</div></pre></td></tr></table></figure>
<h2 id="建立站点"><a href="#建立站点" class="headerlink" title="建立站点"></a>建立站点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init blog</div></pre></td></tr></table></figure>
<p>blog目录就是你的站点根目录，目录里面的<code>_config.yml</code>是<code>站点配置文件</code>，后面还会说到<code>主题配置文件</code>，每一个主题都用一个<code>_config.yml</code>文件，不要搞混了，到目前为止博客环境已经搭建完成。</p>
<h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><p>博客搭建好了，没有run起来感觉心里是虚的，接下来我们把博客run起来看，首先生成静态页面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo generate(可以缩写成g)</div></pre></td></tr></table></figure>
<p>启动本地服务，在浏览器输入<a href="http://localhost:4000就可以看效果了。" target="_blank" rel="external">http://localhost:4000就可以看效果了。</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server(可以缩写成s)</div></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/hexo2.png" alt="此处输入图片的描述"><br>看到上图出现，说明搭建博客成功。</p>
<h2 id="配置github"><a href="#配置github" class="headerlink" title="配置github"></a>配置github</h2><p>hexo生成的静态页面是要上传到github上面的，所以需要配置好github，首先需要在github上建立一个仓库，仓库名格式是<code>username.github.io</code>，比如我的就是<code>chxuan.github.io</code>，不要乱取，不然配置不成功。之后编辑<code>站点配置文件</code>在末尾加入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repo: https://github.com/chxuan/chxuan.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>repo行需要替换成你自己的仓库路径，保存之后运行如下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div><div class="line">hexo deploy(可以缩写成d)</div></pre></td></tr></table></figure>
<p>至此hexo已经关联好了github，在浏览器输入<a href="http://username.github.io/，比如我的是http://chxuan.github.io/就可以浏览了，github默认提供的是一个二级域名，你也可去阿里云购买域名，替换掉github提供的。" target="_blank" rel="external">http://username.github.io/，比如我的是http://chxuan.github.io/就可以浏览了，github默认提供的是一个二级域名，你也可去阿里云购买域名，替换掉github提供的。</a></p>
<h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hexo new <span class="string">"xxxxxxxx"</span> </div><div class="line">hexo clean</div><div class="line">hexo generate(可以缩写成g)</div><div class="line">hexo deploy(可以缩写成d)</div></pre></td></tr></table></figure>
<p>以上是发表文章的步骤，执行hexo new 之后会在站点目录的<code>source/_posts/</code>目录下生成<code>.md</code>结尾的博客，我用的<a href="https://www.zybuluo.com/mdedito" target="_blank" rel="external">Cmd Mardown</a>来写博客的。</p>
<h2 id="创建一个标签页"><a href="#创建一个标签页" class="headerlink" title="创建一个标签页"></a>创建一个标签页</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hexo new page <span class="string">"about"</span> </div><div class="line">hexo clean</div><div class="line">hexo generate(可以缩写成g)</div><div class="line">hexo deploy(可以缩写成d)</div></pre></td></tr></table></figure>
<p>上面创建了一个关于我的标签页并部署到github服务器上。</p>
<h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>我使用的是<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT</a>主题，目前github星星数最多的一个主题，主题界面一般，主要是文档齐全吧，所以很受人们欢迎，我也建议新手使用该主题，主题配置参考<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="external">NexT官方文档</a>。<br><img src="https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/hexo3.png" alt="此处输入图片的描述"></p>
<h2 id="集成第三方插件"><a href="#集成第三方插件" class="headerlink" title="集成第三方插件"></a>集成第三方插件</h2><p>若想要别人评论你的博客、查看访问次数、搜索博客等功能需要第三方插件支持，你可以参考<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="external">NexT官方文档</a>。</p>
<h2 id="多电脑发布博客"><a href="#多电脑发布博客" class="headerlink" title="多电脑发布博客"></a>多电脑发布博客</h2><p>公司电脑和家用电脑都可以写博客，当环境搭建好后，怎么进行文章同步呢，我使用的是github，我在github上创建了一个名为blog的仓库用来存放博客文件，你需要将本地站点blog目录进行<code>hexo clean</code>之后，<code>hexo clean</code>执行过后就是删除<code>public</code>里面生成的静态页面等操作，将剩下的文件放入github同步就可以了。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo官方文档</a></li>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">NexT主题官方文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chxuan/images/master/blog/2016/10/hexo.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上大学期间都没有做笔记、写博客的习惯，工作以后学的东西多了，接触的东西多了，才发现做笔记是一件很重要的事情，做笔记可以将自己的想法、思路写下来，方便以后查阅，俗话说好记性不如键盘党，做笔记、写博客也可以让自己学会总结、学会分享，今年年初才开始使用cnblogs来写博客，账号已经申请了两年多了，大学期间一直没用，cnblogs写了一段时间发现网上一些大牛都有自己的博客，因为我比较喜欢折腾和装X，所以我也打算搭建一个博客，我不是做web方向的，也不懂jsp、asp.net、php（世界上最好的语言）、webpy等语言和技术（大学时学过，后来就忘了），之前我看到我同学基于&lt;a href=&quot;https://cn.wordpress.org/&quot;&gt;WordPress&lt;/a&gt;搭建了一个&lt;a href=&quot;http://www.lampnick.com/&quot;&gt;博客&lt;/a&gt;，这个需要数据库啊，服务器之类的，感觉有点麻烦，后来在网上查阅资料看到&lt;a href=&quot;https://hexo.io/zh-cn/&quot;&gt;hexo&lt;/a&gt;、&lt;a href=&quot;http://jekyll.com.cn/&quot;&gt;jekyll&lt;/a&gt;配合github就可以用来搭建博客，github作为服务器这样还省去了租用服务器的费用，有人会问国内的&lt;a href=&quot;https://coding.net/&quot;&gt;coding&lt;/a&gt;也可以作为部署服务器啊，还快些，我只想说信仰不同，不相为谋，存储图片我也是用的github，没有用七牛的，最后我选择的hexo + github方案来制作个人博客，我是在ubuntu上搭建的，在windows和mac上搭建的朋友本篇博客还是有参考意义，下面是详细的制作过程(个人博客也发表了&lt;a href=&quot;http://chengxuan.me/2016/10/19/%E4%BD%BF%E7%94%A8hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/&quot;&gt;《使用hexo+github搭建个人博客》&lt;/a&gt;)。&lt;/p&gt;
    
    </summary>
    
      <category term="制作个人博客" scheme="http://yoursite.com/categories/%E5%88%B6%E4%BD%9C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
</feed>
